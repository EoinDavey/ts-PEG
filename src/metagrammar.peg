// Meta grammar for parser

GRAM      := header=HDR? rules=RULEDEF+
HDR       := '---' content='((?!---)(.|\n))*' '---'
RULEDEF   := _ name=NAME _ ':=' _ rule=RULE _
RULE      := head=ALT tail={_ '\|' _ alt=ALT }*
          .list = ALT[] { return [this.head, ...this.tail.map((x) => x.alt)]; }
ALT       := matches=MATCHSPEC+ attrs=ATTR*
MATCHSPEC := _ named={name=NAME _ '=' _}? rule=MATCH
MATCH     := SPECIAL | POSTOP
SPECIAL   := op='@'
POSTOP    := pre=PREOP op='\+|\*|\?'?
            .optional = boolean { return this.op === '?';}
PREOP     := op='\&|!'? at=ATOM
ATOM      := name=NAME !'\s*:='
           | match=STRLIT
           | '{' _ sub=RULE _ '}'
ATTR      := _ '\.' name=NAME _ '=' _ type='[^\s\{]+' _ '\{'
    action='([^\{\}\\]|(\\.))*'
'\}'
NAME      := '[a-zA-Z_][a-zA-Z0-9_]*'
STRLIT    := start=@ '\'' val='([^\'\\]|(\\.))*' '\''

// Whitespace definition includes traditional whitespace
// and // comments.
_         := '(?:\s|(?:\/\/.*(?:\n|$)))*'

// Grammar to match TypeScript type defs

TS_TYPE := TS_EXPR | TS_FUNCTION | TS_CONSTRUCTOR

TS_EXPR := TS_PRIM { '[&|]' TS_PRIM }*
TS_PRIM := '\(' TS_TYPE '\)'
    | TS_TYPE_REF

TS_TYPE_REF := NAME {'\.' NAME}* TS_GENERIC_PARAMS?

TS_FUNCTION := TS_GENERIC_PARAMS? '\(' TS_PARAM_LIST? '\)' '=>' TS_TYPE
TS_CONSTRUCTOR := 'new' TS_FUNCTION

TS_GENERIC_PARAMS := '<' {TS_GENERIC_PARAM {',' TS_GENERIC_PARAM}* }? '>'
TS_GENERIC_PARAM := NAME {_ 'extends' TS_TYPE}?

TS_PARAM_LIST := TS_REQUIRED_PARAMS {',' TS_OPTIONAL_PARAMS}? {',' TS_REST_PARAM}?
    | TS_OPTIONAL_PARAMS {',' TS_REST_PARAM}?
    | TS_REST_PARAM

TS_REQUIRED_PARAMS := TS_REQUIRED_PARAM {',' TS_REQUIRED_PARAM}*
TS_REQUIRED_PARAM := NAME ':' TS_TYPE

TS_OPTIONAL_PARAMS := TS_OPTIONAL_PARAM {',' TS_OPTIONAL_PARAM}*
TS_OPTIONAL_PARAM := NAME '\?' ':' TS_TYPE

TS_REST_PARAM := '\.\.\.' NAME ':' TS_TYPE
