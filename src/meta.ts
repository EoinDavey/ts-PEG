/* AutoGenerated Code, changes may be overwritten
* INPUT GRAMMAR:
* GRAM      := RULEDEF+
* RULEDEF   := _ name=NAME _ ':=' _ rule=RULE _
* RULE      := head=ALT tail={_ '\|' _ alt=ALT }*
* ALT       := MATCHSPEC+
* MATCHSPEC := _ named={name=NAME '='}? rule=POSTOP _
* POSTOP    := pre=PREOP op='\+|\*|\?'?
* PREOP     := op='\&|!'? at=ATOM
* ATOM      := name=NAME !'\s*:='
*            | match=STRLIT
*            | '{' _ sub=RULE _ '}'
* NAME      := '[a-zA-Z_]+'
* STRLIT    := '\'' val='([^\'\\]|(\\.))*' '\''
* _         := '\s*'
*/
type Nullable<T> = T | null;
type $$RuleType<T> = (log? : (msg : string) => void) => Nullable<T>;
export interface ContextRecorder {
    record(pos: PosInfo, depth : number, result: any, negating : boolean, extraInfo : string[]) : void;
}
interface ASTNodeIntf {
    kind: ASTKinds;
}
export enum ASTKinds {
    GRAM,
    RULEDEF,
    RULE,
    RULE_$0,
    ALT,
    MATCHSPEC,
    MATCHSPEC_$0,
    POSTOP,
    PREOP,
    ATOM_1,
    ATOM_2,
    ATOM_3,
    NAME,
    STRLIT,
    _,
}
export type GRAM = RULEDEF[];
export class RULEDEF implements ASTNodeIntf {
    kind : ASTKinds.RULEDEF = ASTKinds.RULEDEF;
    name : NAME;
    rule : RULE;
    constructor(name : NAME, rule : RULE){
        this.name = name;
        this.rule = rule;
    }
}
export class RULE implements ASTNodeIntf {
    kind : ASTKinds.RULE = ASTKinds.RULE;
    head : ALT;
    tail : RULE_$0[];
    constructor(head : ALT, tail : RULE_$0[]){
        this.head = head;
        this.tail = tail;
    }
}
export class RULE_$0 implements ASTNodeIntf {
    kind : ASTKinds.RULE_$0 = ASTKinds.RULE_$0;
    alt : ALT;
    constructor(alt : ALT){
        this.alt = alt;
    }
}
export type ALT = MATCHSPEC[];
export class MATCHSPEC implements ASTNodeIntf {
    kind : ASTKinds.MATCHSPEC = ASTKinds.MATCHSPEC;
    named : Nullable<MATCHSPEC_$0>;
    rule : POSTOP;
    constructor(named : Nullable<MATCHSPEC_$0>, rule : POSTOP){
        this.named = named;
        this.rule = rule;
    }
}
export class MATCHSPEC_$0 implements ASTNodeIntf {
    kind : ASTKinds.MATCHSPEC_$0 = ASTKinds.MATCHSPEC_$0;
    name : NAME;
    constructor(name : NAME){
        this.name = name;
    }
}
export class POSTOP implements ASTNodeIntf {
    kind : ASTKinds.POSTOP = ASTKinds.POSTOP;
    pre : PREOP;
    op : Nullable<string>;
    constructor(pre : PREOP, op : Nullable<string>){
        this.pre = pre;
        this.op = op;
    }
}
export class PREOP implements ASTNodeIntf {
    kind : ASTKinds.PREOP = ASTKinds.PREOP;
    op : Nullable<string>;
    at : ATOM;
    constructor(op : Nullable<string>, at : ATOM){
        this.op = op;
        this.at = at;
    }
}
export type ATOM = ATOM_1 | ATOM_2 | ATOM_3;
export class ATOM_1 implements ASTNodeIntf {
    kind : ASTKinds.ATOM_1 = ASTKinds.ATOM_1;
    name : NAME;
    constructor(name : NAME){
        this.name = name;
    }
}
export class ATOM_2 implements ASTNodeIntf {
    kind : ASTKinds.ATOM_2 = ASTKinds.ATOM_2;
    match : STRLIT;
    constructor(match : STRLIT){
        this.match = match;
    }
}
export class ATOM_3 implements ASTNodeIntf {
    kind : ASTKinds.ATOM_3 = ASTKinds.ATOM_3;
    sub : RULE;
    constructor(sub : RULE){
        this.sub = sub;
    }
}
export type NAME = string;
export class STRLIT implements ASTNodeIntf {
    kind : ASTKinds.STRLIT = ASTKinds.STRLIT;
    val : string;
    constructor(val : string){
        this.val = val;
    }
}
export type _ = string;
export class Parser {
    private pos : PosInfo;
    readonly input : string;
    private negating: boolean = false;
    constructor(input : string) {
        this.pos = new PosInfo(0, 1, 0);
        this.input = input;
    }
    private mark() : PosInfo {
        return this.pos;
    }
    reset(pos : PosInfo) {
        this.pos = pos;
    }
    finished() : boolean {
        return this.pos.overall_pos === this.input.length;
    }
    private loop<T>(func : $$RuleType<T>, star : boolean = false) : Nullable<T[]> {
        const mrk = this.mark();
        let res : T[] = [];
        for(;;) {
            const t = func();
            if(!t)
                break;
            res.push(t);
        }
        if(star || res.length > 0)
            return res;
        this.reset(mrk);
        return null;
    }
    private runner<T>($$dpth : number, fn : $$RuleType<T>,
        cr? : ContextRecorder) : $$RuleType<T> {
        return () => {
            const mrk = this.mark();
            const res = cr ? (()=>{
                let extraInfo : string[] = [];
                const res = fn((msg : string) => extraInfo.push(msg));
                cr.record(mrk, $$dpth, res, this.negating, extraInfo);
                return res;
            })() : fn();
            if(res !== null)
                return res;
            this.reset(mrk);
            return null
        }
    }
    private choice<T>(fns : $$RuleType<T>[]) : Nullable<T> {
        for(let f of fns){
            const res = f();
            if(res)
                return res;
        }
        return null;
    }
    private regexAccept(match : string, dpth : number, cr? : ContextRecorder) : Nullable<string> {
        return this.runner<string>(dpth,
            (log) => {
                if(log){
                    if(this.negating)
                        log('$$!StrMatch');
                    else
                        log('$$StrMatch');
                    log(match);
                }
                var reg = new RegExp(match, 'y');
                reg.lastIndex = this.mark().overall_pos;
                const res = reg.exec(this.input);
                if(res){
                    let lineJmp = 0;
                    let lind = -1;
                    for(let i = 0; i < res[0].length; ++i){
                        if(res[0][i] === '\n'){
                            ++lineJmp;
                            lind = i;
                        }
                    }
                    this.pos = new PosInfo(reg.lastIndex, this.pos.line + lineJmp, lind === -1 ? this.pos.offset + res[0].length: (res[0].length - lind));
                    return res[0];
                }
                return null;
            }, cr)();
    }
    private noConsume<T>(fn : $$RuleType<T>) : Nullable<T> {
        const mrk = this.mark();
        const res = fn();
        this.reset(mrk);
        return res;
    }
    private negate<T>(fn : $$RuleType<T>) : Nullable<boolean> {
        const mrk = this.mark();
        const oneg = this.negating;
        this.negating = !oneg
        const res = fn();
        this.negating = oneg;
        this.reset(mrk);
        return res === null ? true : null;
    }
    matchGRAM($$dpth : number, cr? : ContextRecorder) : Nullable<GRAM> {
        return this.loop<RULEDEF>(()=> this.matchRULEDEF($$dpth + 1, cr), false);
    }
    matchRULEDEF($$dpth : number, cr? : ContextRecorder) : Nullable<RULEDEF> {
        return this.runner<RULEDEF>($$dpth,
            (log) => {
                if(log)
                    log('RULEDEF');
                let name : Nullable<NAME>;
                let rule : Nullable<RULE>;
                let res : Nullable<RULEDEF> = null;
                if(true
                    && this.match_($$dpth + 1, cr) != null
                    && (name = this.matchNAME($$dpth + 1, cr)) != null
                    && this.match_($$dpth + 1, cr) != null
                    && this.regexAccept(String.raw`:=`, $$dpth+1, cr) != null
                    && this.match_($$dpth + 1, cr) != null
                    && (rule = this.matchRULE($$dpth + 1, cr)) != null
                    && this.match_($$dpth + 1, cr) != null
                )
                    res = new RULEDEF(name, rule);
                return res;
            }, cr)();
    }
    matchRULE($$dpth : number, cr? : ContextRecorder) : Nullable<RULE> {
        return this.runner<RULE>($$dpth,
            (log) => {
                if(log)
                    log('RULE');
                let head : Nullable<ALT>;
                let tail : Nullable<RULE_$0[]>;
                let res : Nullable<RULE> = null;
                if(true
                    && (head = this.matchALT($$dpth + 1, cr)) != null
                    && (tail = this.loop<RULE_$0>(()=> this.matchRULE_$0($$dpth + 1, cr), true)) != null
                )
                    res = new RULE(head, tail);
                return res;
            }, cr)();
    }
    matchRULE_$0($$dpth : number, cr? : ContextRecorder) : Nullable<RULE_$0> {
        return this.runner<RULE_$0>($$dpth,
            (log) => {
                if(log)
                    log('RULE_$0');
                let alt : Nullable<ALT>;
                let res : Nullable<RULE_$0> = null;
                if(true
                    && this.match_($$dpth + 1, cr) != null
                    && this.regexAccept(String.raw`\|`, $$dpth+1, cr) != null
                    && this.match_($$dpth + 1, cr) != null
                    && (alt = this.matchALT($$dpth + 1, cr)) != null
                )
                    res = new RULE_$0(alt);
                return res;
            }, cr)();
    }
    matchALT($$dpth : number, cr? : ContextRecorder) : Nullable<ALT> {
        return this.loop<MATCHSPEC>(()=> this.matchMATCHSPEC($$dpth + 1, cr), false);
    }
    matchMATCHSPEC($$dpth : number, cr? : ContextRecorder) : Nullable<MATCHSPEC> {
        return this.runner<MATCHSPEC>($$dpth,
            (log) => {
                if(log)
                    log('MATCHSPEC');
                let named : Nullable<Nullable<MATCHSPEC_$0>>;
                let rule : Nullable<POSTOP>;
                let res : Nullable<MATCHSPEC> = null;
                if(true
                    && this.match_($$dpth + 1, cr) != null
                    && ((named = this.matchMATCHSPEC_$0($$dpth + 1, cr)) || true)
                    && (rule = this.matchPOSTOP($$dpth + 1, cr)) != null
                    && this.match_($$dpth + 1, cr) != null
                )
                    res = new MATCHSPEC(named, rule);
                return res;
            }, cr)();
    }
    matchMATCHSPEC_$0($$dpth : number, cr? : ContextRecorder) : Nullable<MATCHSPEC_$0> {
        return this.runner<MATCHSPEC_$0>($$dpth,
            (log) => {
                if(log)
                    log('MATCHSPEC_$0');
                let name : Nullable<NAME>;
                let res : Nullable<MATCHSPEC_$0> = null;
                if(true
                    && (name = this.matchNAME($$dpth + 1, cr)) != null
                    && this.regexAccept(String.raw`=`, $$dpth+1, cr) != null
                )
                    res = new MATCHSPEC_$0(name);
                return res;
            }, cr)();
    }
    matchPOSTOP($$dpth : number, cr? : ContextRecorder) : Nullable<POSTOP> {
        return this.runner<POSTOP>($$dpth,
            (log) => {
                if(log)
                    log('POSTOP');
                let pre : Nullable<PREOP>;
                let op : Nullable<Nullable<string>>;
                let res : Nullable<POSTOP> = null;
                if(true
                    && (pre = this.matchPREOP($$dpth + 1, cr)) != null
                    && ((op = this.regexAccept(String.raw`\+|\*|\?`, $$dpth+1, cr)) || true)
                )
                    res = new POSTOP(pre, op);
                return res;
            }, cr)();
    }
    matchPREOP($$dpth : number, cr? : ContextRecorder) : Nullable<PREOP> {
        return this.runner<PREOP>($$dpth,
            (log) => {
                if(log)
                    log('PREOP');
                let op : Nullable<Nullable<string>>;
                let at : Nullable<ATOM>;
                let res : Nullable<PREOP> = null;
                if(true
                    && ((op = this.regexAccept(String.raw`\&|!`, $$dpth+1, cr)) || true)
                    && (at = this.matchATOM($$dpth + 1, cr)) != null
                )
                    res = new PREOP(op, at);
                return res;
            }, cr)();
    }
    matchATOM($$dpth : number, cr? : ContextRecorder) : Nullable<ATOM> {
        return this.choice<ATOM>([
            () => { return this.matchATOM_1($$dpth + 1, cr) },
            () => { return this.matchATOM_2($$dpth + 1, cr) },
            () => { return this.matchATOM_3($$dpth + 1, cr) },
        ]);
    }
    matchATOM_1($$dpth : number, cr? : ContextRecorder) : Nullable<ATOM_1> {
        return this.runner<ATOM_1>($$dpth,
            (log) => {
                if(log)
                    log('ATOM_1');
                let name : Nullable<NAME>;
                let res : Nullable<ATOM_1> = null;
                if(true
                    && (name = this.matchNAME($$dpth + 1, cr)) != null
                    && this.negate(() => this.regexAccept(String.raw`\s*:=`, $$dpth+1, cr)) != null
                )
                    res = new ATOM_1(name);
                return res;
            }, cr)();
    }
    matchATOM_2($$dpth : number, cr? : ContextRecorder) : Nullable<ATOM_2> {
        return this.runner<ATOM_2>($$dpth,
            (log) => {
                if(log)
                    log('ATOM_2');
                let match : Nullable<STRLIT>;
                let res : Nullable<ATOM_2> = null;
                if(true
                    && (match = this.matchSTRLIT($$dpth + 1, cr)) != null
                )
                    res = new ATOM_2(match);
                return res;
            }, cr)();
    }
    matchATOM_3($$dpth : number, cr? : ContextRecorder) : Nullable<ATOM_3> {
        return this.runner<ATOM_3>($$dpth,
            (log) => {
                if(log)
                    log('ATOM_3');
                let sub : Nullable<RULE>;
                let res : Nullable<ATOM_3> = null;
                if(true
                    && this.regexAccept(String.raw`{`, $$dpth+1, cr) != null
                    && this.match_($$dpth + 1, cr) != null
                    && (sub = this.matchRULE($$dpth + 1, cr)) != null
                    && this.match_($$dpth + 1, cr) != null
                    && this.regexAccept(String.raw`}`, $$dpth+1, cr) != null
                )
                    res = new ATOM_3(sub);
                return res;
            }, cr)();
    }
    matchNAME($$dpth : number, cr? : ContextRecorder) : Nullable<NAME> {
        return this.regexAccept(String.raw`[a-zA-Z_]+`, $$dpth+1, cr);
    }
    matchSTRLIT($$dpth : number, cr? : ContextRecorder) : Nullable<STRLIT> {
        return this.runner<STRLIT>($$dpth,
            (log) => {
                if(log)
                    log('STRLIT');
                let val : Nullable<string>;
                let res : Nullable<STRLIT> = null;
                if(true
                    && this.regexAccept(String.raw`\'`, $$dpth+1, cr) != null
                    && (val = this.regexAccept(String.raw`([^\'\\]|(\\.))*`, $$dpth+1, cr)) != null
                    && this.regexAccept(String.raw`\'`, $$dpth+1, cr) != null
                )
                    res = new STRLIT(val);
                return res;
            }, cr)();
    }
    match_($$dpth : number, cr? : ContextRecorder) : Nullable<_> {
        return this.regexAccept(String.raw`\s*`, $$dpth+1, cr);
    }
    parse() : ParseResult {
        const mrk = this.mark();
        const res = this.matchGRAM(0);
        if(res && this.finished())
            return new ParseResult(res, null);
        this.reset(mrk);
        const rec = new ErrorTracker();
        this.matchGRAM(0, rec);
        return new ParseResult(res, rec.getErr());
    }
}
export class ParseResult {
    ast : Nullable<GRAM>;
    err : Nullable<SyntaxErr>;
    constructor(ast : Nullable<GRAM>, err : Nullable<SyntaxErr>){
        this.ast = ast;
        this.err = err;
    }
}
export class PosInfo {
    overall_pos : number;
    line : number;
    offset : number;
    constructor(overall_pos : number, line : number, offset : number) {
        this.overall_pos = overall_pos;
        this.line = line;
        this.offset = offset;
    }
}
export class SyntaxErr {
    pos : PosInfo;
    exprules : string[];
    expmatches : string[]
    constructor(pos : PosInfo, exprules : Set<string>, expmatches : Set<string>){
        this.pos = pos;
        this.exprules = [...exprules];
        this.expmatches = [...expmatches];
    }
    toString() : string {
        return `Syntax Error at line ${this.pos.line}:${this.pos.offset}. Tried to match rules ${this.exprules.join(', ')}. Expected one of ${this.expmatches.map(x => ` '${x}'`)}`;
    }
}
class ErrorTracker implements ContextRecorder {
    mxpos : PosInfo = new PosInfo(-1, -1, -1)
    mnd : number = -1;
    prules : Set<string> = new Set();
    pmatches: Set<string> = new Set();
    record(pos : PosInfo, depth : number, result : any, negating : boolean, extraInfo : string[]){
        if((result === null) === negating)
            return;
        if(pos.overall_pos > this.mxpos.overall_pos){
            this.mxpos = pos;
            this.mnd = depth;
            this.pmatches.clear();
            this.prules.clear();
        } else if(pos.overall_pos === this.mxpos.overall_pos && depth < this.mnd){
            this.mnd = depth;
            this.prules.clear();
        }
        if(this.mxpos.overall_pos === pos.overall_pos && extraInfo.length >= 2) {
            if(extraInfo[0] === '$$StrMatch')
                this.pmatches.add(extraInfo[1]);
            if(extraInfo[0] === '$$!StrMatch')
                this.pmatches.add(`not ${extraInfo[1]}`);
        }
        if(this.mxpos.overall_pos === pos.overall_pos && this.mnd === depth)
            extraInfo.forEach(x => { if(x !== '$$StrMatch' && x !== '$$!StrMatch') this.prules.add(x)});
    }
    getErr() : SyntaxErr | null {
        if(this.mxpos.overall_pos !== -1)
            return new SyntaxErr(this.mxpos, this.prules, this.pmatches);
        return null;
    }
}